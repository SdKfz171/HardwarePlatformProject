###############################################################################
#
# IAR ANSI C/C++ Compiler V8.20.1.14183/W32 for ARM       07/Dec/2017  15:20:34
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\main.c
#    Command line =  
#        -f C:\Users\DELL\AppData\Local\Temp\EWC02A.tmp
#        (C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\main.c -D
#        VECT_TAB_FLASH -lcN
#        C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\EWARMv5\Debug\List
#        -o
#        C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\EWARMv5\Debug\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\EWARMv5\..\ -I
#        C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\EWARMv5\..\..\ -I
#        C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\EWARMv5\..\..\FWLib\library\inc\
#        -Ohs --use_c++_inline --require_prototypes)
#    Locale       =  C
#    List file    =  
#        C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\EWARMv5\Debug\List\main.lst
#    Object file  =  
#        C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\EWARMv5\Debug\Obj\main.o
#
###############################################################################

C:\Users\DELL\Documents\CoretexSource\Source\DAC_1\main.c
      1          #include "stm32f10x_it.h"
      2          #include "stm32f10x_lib.h"
      3          #include "stm32f10x_usart.h"
      4          #include "stm32f10x_adc.h"
      5          #include "stm32f10x_dac.h"
      6          #include "stm32f10x_dma.h"
      7          #include "stm32f10x_flash.h"
      8          #include "stm32f10x_exti.h"
      9          #include <stdio.h>   
     10          #include "main.h"
     11          
     12          
     13          #include "lcd12864.h"
     14          
     15          #include "at24c02.h"
     16          
     17          
     18          #define  ADC1_DR_Address    ((u32)0x4001244C)
     19          u16 ADCConvertedValue[1];
     20          extern u16 adc1_buffer[1];
     21          
     22          
     23          void RCC_Configuration(void);
     24          void GPIO_Configuration(void);
     25          void USART1_Configuration(void);
     26          void ADC_Configuration(void);
     27          void DAC_Configuration(void);
     28          
     29          void Timer2_Init(void);
     30          void Timer3_Init(void);
     31          void EXTI_Config(void);
     32          
     33          void DMA1_Configuration(void);
     34          void NVIC_Configuration(void);
     35          
     36          void USART1_SEND(u8 i); 
     37          void putstr(char *str);
     38          
     39          u8* ConvertNumber(u16 Number);
     40          
     41          extern u8 Buffer_USART1[50],  USART1_rx_end, USART1_len;
     42          
     43          	
     44          u16 A_V  = 0;
     45          u8 Num;
     46          
     47          u8 Servo_Zero=0;
     48          u8 Set_Time = 0;
     49          /******************************************************************************
     50            FLASH Memory @@@@@@ @@@@@@@@@
     51          *******************************************************************************/
     52          
     53          void Flash_Data_Write(void);
     54          void Flash_Data_Read(void);
     55          
     56          void Servo_zero(void);
     57          void Servo_90(void);
     58          void Servo_R90(void);
     59          
     60          #define StartAddr ((u32)0x803F800)           // 2KByte memory allocation
     61          #define EndAddr   ((u32)0x803FFFF) 
     62          
     63          u16 Flash_opt=0;
     64          u8 Flash_Buffer[110];
     65          u8 flag = 0;
     66          u8 Timer_flag = 0;
     67          
     68          /*******************************************************************************/
     69          
     70          void main(void)
     71          {
     72               u8 i, j;
     73               u16 i16, temp16;
     74               u16 AD_value;
     75          	u32 i32;
     76               
     77               RCC_Configuration();
     78               
     79               RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA |  RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |
     80                                       RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE |  RCC_APB2Periph_AFIO, ENABLE);
     81               
     82               RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
     83          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
     84               RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
     85          
     86          
     87               
     88               GPIO_Configuration();
     89               USART1_Configuration();
     90               ADC_Configuration();
     91          	DAC_Configuration();
     92               DMA1_Configuration();
     93               NVIC_Configuration();   
     94          
     95               
     96               putstr("Start Program. \n");
     97               
     98              lcd12864_init();
     99              Set_Draw();
    100              clear_screen();
    101          
    102          
    103              Timer2_Init();
    104                  //LCD12864_Num(0,0,8);
    105              
    106               int beforeData = 0;
    107                  
    108               u8 count = 1;
    109               while(1){  
    110          
    111                         // A_V = ADC_GetConversionValue(ADC1);          
    112                          A_V = adc1_buffer[0];
    113                          
    114                          
    115                       
    116          //                DAC_SetChannel1Data(DAC_Align_12b_R, A_V);
    117          //               
    118          //		DAC_SetChannel1Data(DAC_Align_12b_R, 0x7FF);
    119          //		//DAC_SoftwareTriggerCmd(DAC_Channel_1, ENABLE);
    120          //		delay_ms(500);		
    121          //		DAC_SetChannel1Data(DAC_Align_12b_R, 0x8FF);
    122          		//DAC_SoftwareTriggerCmd(DAC_Channel_1, ENABLE);
    123          //		delay_ms(500);
    124          //		DAC_SetChannel1Data(DAC_Align_12b_R, 0x9FF);
    125          //		//DAC_SoftwareTriggerCmd(DAC_Channel_1, ENABLE);
    126          //  		delay_ms(500);
    127          //		DAC_SetChannel1Data(DAC_Align_12b_R, 0xAFF);
    128          //		//DAC_SoftwareTriggerCmd(DAC_Channel_1, ENABLE);
    129          //  		delay_ms(500);
    130          //		DAC_SetChannel1Data(DAC_Align_12b_R, 0xBFF);
    131          //		//DAC_SoftwareTriggerCmd(DAC_Channel_1, ENABLE);
    132          //  		delay_ms(500);
    133          //		DAC_SetChannel1Data(DAC_Align_12b_R, 0xCFF);
    134          //		//DAC_SoftwareTriggerCmd(DAC_Channel_1, ENABLE);
    135          //  		delay_ms(500);
    136          //		DAC_SetChannel1Data(DAC_Align_12b_R, 0xFFF);
    137          //		//DAC_SoftwareTriggerCmd(DAC_Channel_1, ENABLE);
    138          //		delay_ms(500);
    139                          
    140          
    141                          
    142                          char * STR;
    143                          
    144                          
    145                          // ?@@??@@? ?@@
    146                          if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_6)){
    147                              GPIO_SetBits(GPIOE,GPIO_Pin_2);
    148                              GPIO_ResetBits(GPIOE,GPIO_Pin_3);
    149                              
    150                                
    151                              flag = 1;
    152                              //delay_ms(5000);
    153                                                  
    154                          }
    155                          else if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_6)){
    156                              GPIO_SetBits(GPIOE,GPIO_Pin_3);
    157                              GPIO_ResetBits(GPIOE,GPIO_Pin_2);
    158                          }
    159                          
    160                          if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_1) && flag){
    161                              Servo_R90();
    162                              
    163                              delay_ms(5000 * count);
    164                              flag = 0;
    165                              Servo_90();
    166                              count = 1;
    167                          }
    168                          
    169                          if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2) && flag){
    170                              count++;
    171                          }
    172                         
    173                          
    174                          
    175          //                if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_7)){
    176          //                  putstr("toched!\n");
    177          //                  
    178          //                  if(!flag){
    179          //                    Set_Time = 10;
    180          //                    
    181          //                    Servo_R90();
    182          //                    
    183          //                    flag = 1;
    184          //                    delay_ms(1000);
    185          //                    
    186          ////                    Timer_flag = 1;
    187          ////                    flag = 1;
    188          ////                    u16 Number = A_V;
    189          ////                    int i = 0;
    190          ////                    for (i = 0; i < 4; i++) {
    191          ////                      USART1_SEND( (u8)(Number % 10 + 0x30));
    192          ////                      Number = Number / 10;
    193          //                   }
    194          //                   if(flag){
    195          //                     
    196          //                     putstr("success\n");
    197          //                     delay_ms(500);
    198          //                    Servo_90();
    199          //                  }       
    200          //                }
    201                          
    202                          //USART1_SEND((u8)("\n"));
    203                          //printf("\n");
    204                          
    205                          putstr("\n");
    206               }
    207          }
    208          
    209          void Servo_zero(void)
    210          {
    211                Servo_Zero=15;
    212          }
    213          void Servo_90(void)
    214          {
    215                Servo_Zero=20;
    216          }
    217          void Servo_R90(void)
    218          {
    219                Servo_Zero=10;
    220          }
    221          
    222          u8* ConvertNumber(u16 Number){
    223            u8 u8Array[4];
    224            
    225            int i = 0;
    226            for (i = 0; i < 4; i++) {
    227              u8Array[3 - i] = Number % 10;
    228              Number = Number / 10;
    229            }
    230          
    231          	// for (i = 0; i < 3; i++) {
    232          	// 	printf("%d\n", NumberArray[i]);
    233          	// }
    234            for(i=0;i<4;i++){
    235              u8Array[i] = u8Array[i] + 0x30;
    236            }
    237            
    238            return u8Array;
    239          }
    240          
    241          
    242          void EXTI_Config(void)
    243          {
    244          	GPIO_InitTypeDef GPIO_InitStructure; 
    245          	NVIC_InitTypeDef NVIC_InitStructure;      
    246          	EXTI_InitTypeDef EXTI_InitStructure;
    247          	     
    248                GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    249               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    250               GPIO_Init(GPIOC, &GPIO_InitStructure);  
    251                  
    252               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    253               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    254               GPIO_Init(GPIOC, &GPIO_InitStructure);
    255          	
    256          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    257               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    258               GPIO_Init(GPIOC, &GPIO_InitStructure);
    259               
    260               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
    261               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    262               GPIO_Init(GPIOC, &GPIO_InitStructure);
    263               
    264               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
    265               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    266               GPIO_Init(GPIOC, &GPIO_InitStructure);
    267          	
    268                GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource0);     
    269               GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource1);
    270          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource2);
    271               GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3);
    272               GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource4);
    273          	
    274               EXTI_InitStructure.EXTI_Line = EXTI_Line0;
    275               EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    276               EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  ;  
    277               EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    278               EXTI_Init(&EXTI_InitStructure);  
    279                  
    280               EXTI_InitStructure.EXTI_Line = EXTI_Line1;
    281               EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    282               EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  ;  
    283               EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    284               EXTI_Init(&EXTI_InitStructure);
    285          	
    286          	EXTI_InitStructure.EXTI_Line =  EXTI_Line2;
    287               EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    288               EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  ;  
    289               EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    290               EXTI_Init(&EXTI_InitStructure);
    291               
    292               EXTI_InitStructure.EXTI_Line =  EXTI_Line3;
    293               EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    294               EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  ;  
    295               EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    296               EXTI_Init(&EXTI_InitStructure);
    297               
    298               EXTI_InitStructure.EXTI_Line =  EXTI_Line4;
    299               EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    300               EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  ;  
    301               EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    302               EXTI_Init(&EXTI_InitStructure);
    303          	
    304                  EXTI_ClearITPendingBit(EXTI_Line0);
    305          	EXTI_ClearITPendingBit(EXTI_Line1);
    306          	EXTI_ClearITPendingBit(EXTI_Line2);
    307                  EXTI_ClearITPendingBit(EXTI_Line3);
    308                  EXTI_ClearITPendingBit(EXTI_Line4);
    309                  
    310               NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQChannel;
    311               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    312               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    313               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    314               NVIC_Init(&NVIC_InitStructure);
    315               
    316          	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQChannel;
    317               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    318               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    319               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    320               NVIC_Init(&NVIC_InitStructure);
    321          	
    322          	NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQChannel;
    323               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    324               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    325               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    326               NVIC_Init(&NVIC_InitStructure);
    327               
    328               NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQChannel;
    329               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    330               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    331               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    332               NVIC_Init(&NVIC_InitStructure);
    333               
    334               NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQChannel;
    335               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    336               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    337               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    338               NVIC_Init(&NVIC_InitStructure);
    339          }
    340          
    341          
    342          void Timer2_Init(void)
    343          {
    344          
    345              NVIC_InitTypeDef NVIC_InitStructure;
    346              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    347          
    348              /* TIM2 clock enable */
    349              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); 
    350              
    351              /* Enable the TIM2 global Interrupt */
    352              NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQChannel;
    353              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    354              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    355              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    356              NVIC_Init(&NVIC_InitStructure); 
    357          
    358              /* Time base configuration */
    359              TIM_TimeBaseStructure.TIM_Period = 10-1;       // 0.1msec
    360              TIM_TimeBaseStructure.TIM_Prescaler = 720;      // 1@@@ 100,000 -> 100usec
    361              TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    362              TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    363              TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
    364          
    365             // TIM_PrescalerConfig(TIM2, 4, TIM_PSCReloadMode_Immediate);
    366              
    367              TIM_ARRPreloadConfig(TIM2, ENABLE);
    368              TIM_Cmd(TIM2, ENABLE); 
    369          
    370          
    371               /* TIM IT enable */
    372              TIM_ITConfig(TIM2, TIM_IT_Update , ENABLE);     
    373          
    374          
    375          }
    376          
    377          void Timer3_Init(void)
    378          {
    379              NVIC_InitTypeDef NVIC_InitStructure;
    380              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    381          
    382              /* TIM3 clock enable */
    383              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); 
    384              
    385              /* Enable the TIM3 global Interrupt */
    386              NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQChannel;
    387              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    388              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    389              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    390              NVIC_Init(&NVIC_InitStructure); 
    391          
    392              /* Time base configuration */
    393              TIM_TimeBaseStructure.TIM_Period = 100-1;       // 0.1msec
    394              TIM_TimeBaseStructure.TIM_Prescaler = 7200;      // 1@@@ 100,000 -> 100usec
    395              TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    396              TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    397              TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    398          
    399             // TIM_PrescalerConfig(TIM3, 4, TIM_PSCReloadMode_Immediate);
    400              
    401              TIM_ARRPreloadConfig(TIM3, ENABLE);
    402              TIM_Cmd(TIM3, ENABLE); 
    403          
    404          
    405               /* TIM IT enable */
    406              TIM_ITConfig(TIM3, TIM_IT_Update , ENABLE);     
    407          }
    408          
    409          
    410          
    411          void Flash_Data_Write(void)
    412          {
    413            	u8 i;
    414          	u16 i16;
    415          	
    416          	FLASH_Unlock();	
    417          	
    418          	for(i16=0; i16<255; i16+=2){        // Flash @@@@@@ @@@@@@@@@ @@@@?@@@@ 
    419          		Flash_Buffer[i16]= *(u16 *) (StartAddr+i16);  
    420          	}
    421          	
    422          	FLASH_ErasePage(StartAddr);
    423          	
    424          		
    425          	for(i=0; i<50; i++){           //  data Modify
    426          		Flash_Buffer[(i*2)]= 'A';
    427          	}
    428          	
    429          	for(i16=0; i16<255; i16+=2){    // Flash  @@@@@@@@@ @@@@?@@@@@@
    430          		FLASH_ProgramHalfWord(StartAddr+i16, Flash_Buffer[i16]);
    431          	}
    432          			
    433          	FLASH_Lock(); 
    434          }
    435          
    436          
    437          void Flash_Data_Read(void)
    438          {
    439          	u8 i;
    440          	u16 j=0;
    441          
    442          	
    443          	FLASH_Unlock();
    444          	
    445          	for(i=0; i<100; i+=2){
    446          		Flash_Buffer[j]= *(u16 *)(StartAddr+i);  
    447          		j++;
    448          	}
    449          	FLASH_Lock();		
    450          }
    451          
    452          void USART1_SEND(u8 i)
    453          {
    454              USART_SendData(USART1, i);     
    455              while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);      
    456          }
    457          
    458          void putstr(char *str) 
    459          { 
    460               char ch;     
    461               while((ch=*str)!= '\0') { 
    462          	USART_SendData(USART1, *str);     
    463          	while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);    
    464          	str++; 
    465               } 
    466           }
    467          
    468          
    469          
    470          void GPIO_Configuration(void)
    471          {
    472               GPIO_InitTypeDef GPIO_InitStructure;      
    473               
    474               RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); 
    475               RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); 
    476          
    477               
    478               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;          //USART1, TX
    479               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    480               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    481               GPIO_Init(GPIOA, &GPIO_InitStructure);   
    482          
    483               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;          //USART1, RX
    484               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    485               GPIO_Init(GPIOA, &GPIO_InitStructure); 
    486          
    487           
    488                 // KEY
    489               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7 |
    490                                             GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_6 | GPIO_Pin_13 | GPIO_Pin_15;
    491               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    492               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   
    493               GPIO_Init(GPIOC, &GPIO_InitStructure);
    494          
    495                 // LED
    496               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4; 
    497               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    498               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   
    499               GPIO_Init(GPIOE, &GPIO_InitStructure);      
    500               
    501                 // Analog Input
    502               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; 
    503               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    504               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   
    505               GPIO_Init(GPIOC, &GPIO_InitStructure); 
    506               
    507                 // Analog Input
    508               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; 
    509               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    510               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   
    511               GPIO_Init(GPIOB, &GPIO_InitStructure); 
    512               
    513               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; 
    514               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    515               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   
    516               GPIO_Init(GPIOD, &GPIO_InitStructure);
    517               
    518          }  
    519          
    520          
    521          void USART1_Configuration(void)
    522          {
    523               USART_InitTypeDef USART_InitStructure;
    524               USART_ClockInitTypeDef  USART_ClockInitStructure;     
    525               NVIC_InitTypeDef NVIC_InitStructure;      
    526               
    527               USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
    528               USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
    529               USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
    530               USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
    531               USART_ClockInit(USART1, &USART_ClockInitStructure);
    532          
    533               USART_InitStructure.USART_BaudRate = 115200;
    534               USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    535               USART_InitStructure.USART_StopBits = USART_StopBits_1;
    536               USART_InitStructure.USART_Parity = USART_Parity_No ;
    537               USART_InitStructure.USART_HardwareFlowControl =   USART_HardwareFlowControl_None;
    538          
    539               USART_InitStructure.USART_Mode = USART_Mode_Rx |  USART_Mode_Tx;     
    540               USART_Init(USART1, &USART_InitStructure);         
    541               USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);              
    542               NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel; 
    543               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;   
    544               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;         
    545               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;             
    546               NVIC_Init(&NVIC_InitStructure);     
    547               USART_Cmd(USART1, ENABLE);
    548          }
    549          
    550          void DAC_Configuration(void)
    551          {
    552          	DAC_InitTypeDef DAC_InitStructure;
    553          	GPIO_InitTypeDef GPIO_InitStructure;
    554          
    555          	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_4;
    556            	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    557          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
    558            	GPIO_Init(GPIOA, &GPIO_InitStructure);
    559          	
    560          	/* DAC channel1 Configuration */
    561               DAC_InitStructure.DAC_Trigger = DAC_Trigger_None;
    562          	// DAC_InitStructure.DAC_Trigger = DAC_Trigger_Software;
    563            	DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_Noise;
    564            	DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bits11_0;
    565            	DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
    566          	//DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Disable;
    567            	DAC_Init(DAC_Channel_1, &DAC_InitStructure);
    568          
    569            	/* Enable DAC Channel1: Once the DAC channel1 is enabled, PA.04 is 
    570               	automatically connected to the DAC converter. */
    571            	DAC_Cmd(DAC_Channel_1, ENABLE);
    572          }
    573          
    574          void ADC_Configuration(void)
    575          {
    576               ADC_InitTypeDef ADC_InitStructure;
    577          
    578               ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    579               ADC_InitStructure.ADC_ScanConvMode = ENABLE;
    580               ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
    581               ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    582               ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    583               ADC_InitStructure.ADC_NbrOfChannel = 1;
    584               ADC_Init(ADC1, &ADC_InitStructure);
    585          
    586               ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_55Cycles5);
    587             
    588               ADC_DMACmd(ADC1, ENABLE);
    589               ADC_Cmd(ADC1, ENABLE);
    590               ADC_ResetCalibration(ADC1); 
    591               
    592               while(ADC_GetResetCalibrationStatus(ADC1));
    593                  ADC_StartCalibration(ADC1);     
    594               while(ADC_GetCalibrationStatus(ADC1));
    595                  ADC_SoftwareStartConvCmd(ADC1, ENABLE);    
    596          }
    597          
    598          void DMA1_Configuration(void)
    599           {
    600           
    601           	DMA_InitTypeDef DMA_InitStructure; 	
    602          
    603            	DMA_DeInit(DMA1_Channel1);
    604            	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;         	   // DMA @@@@@@@@ @@@@@@@@@ @@@@@@ @@@@@@@
    605            	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADCConvertedValue;          // DMA @@@@ @@@@@@@@@ @@@@@@ @@@@@@@
    606            	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                      // @@@@@@@@ @@@@@@@@@@ @@@@@@ @@@@@@@@@@
    607            	DMA_InitStructure.DMA_BufferSize = 1;                                   // @@@@@@ @@@@@@@@@ @@@@(byte@@@@@@)
    608            	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;                // @@@@@@@@@@ @@@@@@@@ @@@@@@@@@ @@@@@@@?@@@@@@ @@@@@@
    609          
    610               DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;  
    611            	//DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                     // @@@@@@@@@@ @@@@ @@@@@@@@@ @@@@@@@?@@@@@@ @@@@@@  
    612            
    613            	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;      // @@@@@@@@@@@@@@ @@@@@@@ 16bit
    614            	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;           // @@@@@@@@@ @@@@@@@ 16bit
    615            	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;                               // @@@@ @ @@@@? @@@@@@ @@@@@@@@@ @@@@ @@@@@@@@@@@@ @@@@ reload
    616            	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                           // DMA @@@@@@@@@ @@@@@@
    617            	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;                                        // @@@@ to @@@@ @@@@?@@@@
    618            	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
    619            
    620            	DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);  //TC:Transfer complete
    621            
    622            	/* Enable DMA1 channel1 */
    623            	DMA_Cmd(DMA1_Channel1, ENABLE); 
    624          }
    625          
    626          
    627          
    628          void NVIC_Configuration(void)
    629          {
    630          	NVIC_InitTypeDef NVIC_InitStructure;
    631          	
    632          	#ifdef  VECT_TAB_RAM  
    633            	/* Set the Vector Table base location at 0x20000000 */ 
    634            	NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
    635          	#else  /* VECT_TAB_FLASH  */
    636            	/* Set the Vector Table base location at 0x08000000 */ 
    637            	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
    638          	#endif
    639            
    640           	NVIC_InitStructure.NVIC_IRQChannel=DMA1_Channel1_IRQChannel;
    641            	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0;
    642            	NVIC_InitStructure.NVIC_IRQChannelSubPriority=0;
    643            	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
    644            	NVIC_Init(&NVIC_InitStructure);  
    645            
    646          }
    647          
    648          void RCC_Configuration(void)
    649          {   
    650               ErrorStatus HSEStartUpStatus;
    651               /* RCC system reset(for debug purpose) */
    652               RCC_DeInit();
    653          
    654               /* Enable HSE */
    655               RCC_HSEConfig(RCC_HSE_ON);       
    656          
    657               /* Wait till HSE is ready */
    658               HSEStartUpStatus = RCC_WaitForHSEStartUp();
    659          
    660               if(HSEStartUpStatus == SUCCESS)
    661               {
    662                    /* Enable Prefetch Buffer */
    663                    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
    664          
    665                    /* Flash 2 wait state */
    666                    FLASH_SetLatency(FLASH_Latency_2);
    667           	
    668                    /* HCLK = SYSCLK */
    669                    RCC_HCLKConfig(RCC_SYSCLK_Div1); 
    670            
    671                    /* PCLK2 = HCLK */
    672                    RCC_PCLK2Config(RCC_HCLK_Div1); 
    673          
    674                    /* PCLK1 = HCLK/2 */
    675                    RCC_PCLK1Config(RCC_HCLK_Div2);
    676          
    677                    /* PLLCLK = 8MHz * 9 = 72 MHz */
    678                    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
    679          
    680                    /* Enable PLL */ 
    681                    RCC_PLLCmd(ENABLE);
    682          
    683                    /* Wait till PLL is ready */
    684                    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
    685                    {
    686                    }
    687          
    688                    /* Select PLL as system clock source */
    689                    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
    690          
    691                    /* Wait till PLL is used as system clock source */
    692                    while(RCC_GetSYSCLKSource() != 0x08)
    693                    {
    694                    }
    695               }
    696          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ADC_Configuration
        32   -> ADC_Cmd
        32   -> ADC_DMACmd
        32   -> ADC_GetCalibrationStatus
        32   -> ADC_GetResetCalibrationStatus
        32   -> ADC_Init
        32   -> ADC_RegularChannelConfig
        32   -> ADC_ResetCalibration
        32   -> ADC_SoftwareStartConvCmd
        32   -> ADC_StartCalibration
       4   ConvertNumber
      24   DAC_Configuration
        24   -> DAC_Cmd
        24   -> DAC_Init
        24   -> GPIO_Init
      56   DMA1_Configuration
        56   -> DMA_Cmd
        56   -> DMA_DeInit
        56   -> DMA_ITConfig
        56   -> DMA_Init
      24   EXTI_Config
        24   -> EXTI_ClearITPendingBit
        24   -> EXTI_Init
        24   -> GPIO_EXTILineConfig
        24   -> GPIO_Init
        24   -> NVIC_Init
       8   Flash_Data_Read
         0   -> FLASH_Lock
         8   -> FLASH_Unlock
      16   Flash_Data_Write
        16   -> FLASH_ErasePage
         0   -> FLASH_Lock
        16   -> FLASH_ProgramHalfWord
        16   -> FLASH_Unlock
      16   GPIO_Configuration
        16   -> GPIO_Init
        16   -> RCC_APB2PeriphClockCmd
       8   NVIC_Configuration
         8   -> NVIC_Init
         8   -> NVIC_SetVectorTable
       8   RCC_Configuration
         8   -> FLASH_PrefetchBufferCmd
         8   -> FLASH_SetLatency
         8   -> RCC_DeInit
         8   -> RCC_GetFlagStatus
         8   -> RCC_GetSYSCLKSource
         8   -> RCC_HCLKConfig
         8   -> RCC_HSEConfig
         8   -> RCC_PCLK1Config
         8   -> RCC_PCLK2Config
         8   -> RCC_PLLCmd
         8   -> RCC_PLLConfig
         8   -> RCC_SYSCLKConfig
         8   -> RCC_WaitForHSEStartUp
       0   Servo_90
       0   Servo_R90
       0   Servo_zero
      24   Timer2_Init
        24   -> NVIC_Init
        24   -> RCC_APB1PeriphClockCmd
        24   -> TIM_ARRPreloadConfig
        24   -> TIM_Cmd
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      24   Timer3_Init
        24   -> NVIC_Init
        24   -> RCC_APB1PeriphClockCmd
        24   -> TIM_ARRPreloadConfig
        24   -> TIM_Cmd
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      40   USART1_Configuration
        40   -> NVIC_Init
        40   -> USART_ClockInit
        40   -> USART_Cmd
        40   -> USART_ITConfig
        40   -> USART_Init
       8   USART1_SEND
         8   -> USART_GetFlagStatus
         8   -> USART_SendData
      24   __read
        24   -> USART_GetFlagStatus
        24   -> USART_ReceiveData
      24   __write
        24   -> USART_GetFlagStatus
        24   -> USART_SendData
       8   delay_ms
         8   -> delay_us
       0   delay_us
      40   main
        40   -> ADC_Configuration
        40   -> DAC_Configuration
        40   -> DMA1_Configuration
        40   -> GPIO_Configuration
        40   -> GPIO_ReadInputDataBit
        40   -> GPIO_ResetBits
        40   -> GPIO_SetBits
        40   -> NVIC_Configuration
        40   -> RCC_AHBPeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
        40   -> RCC_APB2PeriphClockCmd
        40   -> RCC_Configuration
        40   -> Set_Draw
        40   -> Timer2_Init
        40   -> USART1_Configuration
        40   -> USART_GetFlagStatus
        40   -> USART_SendData
        40   -> clear_screen
        40   -> delay_us
        40   -> lcd12864_init
        40   -> putstr
      16   putstr
        16   -> USART_GetFlagStatus
        16   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
       4  ??DataTable9
      20  ?_0
       2  ?_1
       2  ADCConvertedValue
     114  ADC_Configuration
       8  ConvertNumber
      66  DAC_Configuration
      88  DMA1_Configuration
     450  EXTI_Config
     112  Flash_Buffer
      38  Flash_Data_Read
      96  Flash_Data_Write
       2  Flash_opt
     214  GPIO_Configuration
      46  NVIC_Configuration
       1  Num
     104  RCC_Configuration
      10  Servo_90
      10  Servo_R90
       4  Servo_Zero
          flag
          A_V
      10  Servo_zero
       1  Set_Time
     110  Timer2_Init
     104  Timer3_Init
       1  Timer_flag
     114  USART1_Configuration
      26  USART1_SEND
      64  __read
      74  __write
      22  delay_ms
      22  delay_us
     280  main
      40  putstr

 
   123 bytes in section .bss
     2 bytes in section .rodata
 2 194 bytes in section .text
 
 2 194 bytes of CODE  memory
     2 bytes of CONST memory
   123 bytes of DATA  memory

Errors: none
Warnings: 11
